<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Crypto Orderbook Dashboard</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #1a1a1a;
      color: #ffffff;
      transition: background-color 0.3s, color 0.3s;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background-color: #2d2d2d;
      border-radius: 10px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      padding: 25px;
    }
    h1 {
      text-align: center;
      color: #ffffff;
      margin-bottom: 20px;
      font-size: 28px;
    }
    .header-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 30px;
    }
    .status {
      display: flex;
      align-items: center;
      background-color: #333333;
      padding: 8px 15px;
      border-radius: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 10px;
    }
    .connected {
      background-color: #10b981;
      box-shadow: 0 0 5px #10b981;
    }
    .disconnected {
      background-color: #ef4444;
      box-shadow: 0 0 5px #ef4444;
    }
    .controls {
      display: flex;
      justify-content: space-between;
      margin-bottom: 20px;
      flex-wrap: wrap;
      gap: 10px;
    }
    .control-group {
      display: flex;
      flex-direction: row;
      gap: 20px;
      align-items: flex-start;
      flex-wrap: wrap;
      width: 100%;
    }
    .input-controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      flex: 1;
      min-width: 300px;
      max-width: 400px;
    }
    .threshold-controls {
      display: flex;
      flex-direction: row;
      gap: 20px;
      background-color: #2d2d2d;
      padding: 15px;
      border-radius: 8px;
      flex: 2;
      min-width: 500px;
    }
    .threshold-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
      flex: 1;
    }
    .threshold-group label {
      margin-bottom: 2px;
      font-weight: bold;
      font-size: 12px;
      color: #ffffff;
    }
    .threshold-group input[type="range"] {
      height: 3px;
      margin: 10px 0;
    }
    .threshold-group input[type="range"]::-webkit-slider-thumb {
      width: 15px;
      height: 15px;
    }
    .threshold-value {
      margin-top: 2px;
      font-size: 12px;
      color: #ffffff;
      text-align: center;
    }
    .slider-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 5px;
    }
    .indicator-toggle {
      width: 40px;
      height: 8px;
    }
    button {
      padding: 10px 16px;
      background-color: #222c3d;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      transition: background-color 0.2s;
    }
    button:hover {
      background-color: #131a27;
    }
    .refresh-btn {
      background-color: #10b981;
    }
    .refresh-btn:hover {
      background-color: #059669;
    }
    .arb-btn {
      background-color: #f59e0b;
    }
    .arb-btn:hover {
      background-color: #d97706;
    }
    .token-cell {
      font-weight: bold;
      background-color: #333333;
      color: #ffffff;
    }
    .type-cell {
      font-weight: bold;
      width: 60px;
      background-color: #333333;
      color: #ffffff;
    }
    .sell-price {
      color: #ef4444 !important;
    }
    .buy-price {
      color: #10b981 !important;
    }
    .highlight-green {
      background-color: rgba(16, 185, 129, 0.2) !important;
      border: 1px solid rgba(16, 185, 129, 0.4) !important;
    }
    .highlight-red {
      background-color: rgba(239, 68, 68, 0.2) !important;
      border: 1px solid rgba(239, 68, 68, 0.4) !important;
    }
    .opportunities {
      margin-top: 30px;
      padding: 15px;
      background-color: #2d2d2d;
      border-radius: 8px;
      border-left: 4px solid #131b29;
    }
    .opportunities h2 {
      margin-top: 0;
      font-size: 20px;
      color: #ffffff;
    }
    .opportunity-item {
      padding: 10px;
      margin-bottom: 10px;
      background-color: #333333;
      border-radius: 6px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
      color: #ffffff;
    }
    .hidden {
      display: none;
    }
    .exchange-status {
      display: inline-flex;
      align-items: center;
      margin-left: 5px;
    }
    .exchange-status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 5px;
    }
    .exchange-connected {
      background-color: #10b981;
      box-shadow: 0 0 3px #10b981;
    }
    .exchange-disconnected {
      background-color: #ef4444;
      box-shadow: 0 0 3px #ef4444;
    }
    .exchange-no-data {
      background-color: #f59e0b;
      box-shadow: 0 0 3px #f59e0b;
    }
    .status-legend {
      position: fixed;
      right: 20px;
      top: 20px;
      background-color: #2d2d2d;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      font-size: 14px;
      color: #ffffff;
    }
    .status-legend h3 {
      margin: 0 0 15px 0;
      color: #ffffff;
      font-size: 16px;
      border-bottom: 1px solid #444;
      padding-bottom: 10px;
    }
    .status-legend-items {
      margin-bottom: 15px;
    }
    .status-legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
    }
    .status-legend-item:last-child {
      margin-bottom: 0;
    }
    .orderbook-tables-container {
      margin: 20px 0;
      padding: 15px;
      background-color: #1a1a1a;
      border-radius: 8px;
    }
    .orderbook-tables-row {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
    }
    .orderbook-tables-row:last-child {
      margin-bottom: 0;
    }
    .orderbook-table-container {
      flex: 1;
      background-color: #2d2d2d;
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .orderbook-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding: 10px;
      background-color: #333333;
      border-radius: 6px;
    }
    .orderbook-select {
      padding: 8px;
      border: 1px solid #444444;
      border-radius: 4px;
      background-color: #2d2d2d;
      color: #ffffff;
      font-size: 14px;
      min-width: 150px;
    }
    .orderbook-title {
      margin: 0;
      font-size: 16px;
      color: #ffffff;
      text-align: center;
      font-weight: 600;
    }
    .orderbook-content {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    .orderbook-row {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    .orderbook-side {
      flex: 1;
      margin-bottom: 0;
    }
    .orderbook-side h4 {
      margin: 0 0 8px 0;
      color: #374151;
      font-size: 14px;
      text-align: center;
      font-weight: 600;
    }
    .orderbook-side h4:first-child {
      color: #ef4444;
    }
    .orderbook-side h4:last-child {
      color: #10b981;
    }
    .orderbook-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
      overflow-x: hidden;
      background-color: #2d2d2d;
    }
    .orderbook-table th {
      background-color: #333333;
      padding: 8px;
      font-weight: 600;
      color: #ffffff;
      font-size: 13px;
      border: 1px solid #444444;
    }
    .orderbook-table td {
      padding: 8px;
      text-align: right;
      font-family: monospace;
      font-size: 13px;
      color: #ffffff;
      border: 1px solid #444444;
    }
    .orderbook-table tbody tr {
      position: relative;
    }
    .orderbook-table tbody tr.sell {
      color: #ef4444;
    }
    .orderbook-table tbody tr.buy {
      color: #10b981;
    }
    .orderbook-table tbody tr:hover {
      /* background-color: rgba(0,0,0,0.02); */
    }
    .orderbook-table .price {
      font-weight: 600;
    }
    .orderbook-table .amount {
      color: #9ca3af;
    }
    .orderbook-table .total {
      color: #9ca3af;
      font-weight: 500;
    }
    .orderbook-table .depth {
      color: #9ca3af;
    }
    .orderbook-table tbody {
      display: block;
      max-height: calc(24px * 7.5);
      overflow-y: auto;
      overflow-x: hidden;
      scrollbar-width: thin;
      scrollbar-color: #444444 #1a1a1a;
    }
    .orderbook-table thead {
      display: table;
      width: 100%;
      table-layout: fixed;
    }
    .orderbook-table tbody tr {
      display: table;
      width: 100%;
      table-layout: fixed;
    }
    .theme-toggle {
      width: 100%;
      margin-top: 10px;
      background-color: #333333;
      color: #ffffff;
      border: none;
      padding: 8px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    .theme-toggle:hover {
      background-color: #404040;
    }
    .light-theme .container {
      background-color: #ffffff;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    .light-theme h1 {
      color: #1a1a1a;
    }
    .light-theme .status {
      background-color: #f9f9f9;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .light-theme .theme-toggle {
      background-color: #f0f2f5;
      color: #333333;
    }
    .light-theme .theme-toggle:hover {
      background-color: #e5e7eb;
    }
    .light-theme .status-legend {
      background-color: white;
      color: #333333;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .light-theme .status-legend h3 {
      color: #374151;
      border-bottom-color: #e5e7eb;
    }
    .light-theme .orderbook-table-container {
      background-color: white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .light-theme .orderbook-controls {
      background-color: #f3f4f6;
    }
    .light-theme .orderbook-select {
      background-color: white;
      border-color: #e5e7eb;
      color: #374151;
    }
    .light-theme .orderbook-title {
      color: #374151;
    }
    .light-theme .orderbook-table {
      background-color: white;
    }
    .light-theme .orderbook-table th {
      background-color: #f3f4f6;
      color: #374151;
      border-color: #e5e7eb;
    }
    .light-theme .orderbook-table td {
      color: #374151;
      border-color: #e5e7eb;
    }
    .light-theme .orderbook-tables-container {
      background-color: #f9f9f9;
    }
    .light-theme .threshold-controls {
      background-color: #f9f9f9;
    }
    .light-theme .threshold-group label {
      color: #374151;
    }
    .light-theme .threshold-value {
      color: #6b7280;
    }
    .light-theme table {
      background-color: #ffffff;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    }
    .light-theme th, 
    .light-theme td {
      border-color: #e5e7eb;
      color: #374151;
    }
    .light-theme th {
      background-color: #f3f4f6;
      color: #374151;
    }
    .light-theme .token-cell {
      background-color: #f9fafb;
      color: #111827;
    }
    .light-theme .type-cell {
      background-color: #f3f4f6;
      color: #374151;
    }
    .light-theme .opportunities {
      background-color: #f0f9ff;
    }
    .light-theme .opportunities h2 {
      color: #1e40af;
    }
    .light-theme .opportunity-item {
      background-color: white;
      color: #374151;
    }
    .light-theme .orderbook-table .amount,
    .light-theme .orderbook-table .total,
    .light-theme .orderbook-table .depth {
      color: #6b7280;
    }
    .light-theme .orderbook-table tbody {
      scrollbar-color: #d1d5db #f0f2f5;
    }
    /* Стилі для скролбарів */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: #1a1a1a;
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb {
      background: #444444;
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #555555;
    }

    /* Скролбари для світлої теми */
    .light-theme ::-webkit-scrollbar-track {
      background: #f0f2f5;
    }

    .light-theme ::-webkit-scrollbar-thumb {
      background: #d1d5db;
    }

    .light-theme ::-webkit-scrollbar-thumb:hover {
      background: #9ca3af;
    }

    /* Стилі для бігунків */
    input[type="range"] {
      -webkit-appearance: none;
      width: 100%;
      height: 4px;
      background: linear-gradient(90deg, #10b981 0%, #3b82f6 50%, #ef4444 100%);
      border-radius: 2px;
      outline: none;
      margin: 15px 0;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      background: #ffffff;
      border: 2px solid #10b981;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      transition: all 0.2s ease;
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.1);
      box-shadow: 0 3px 6px rgba(0,0,0,0.3);
    }

    .light-theme input[type="range"] {
      background: linear-gradient(90deg, #059669 0%, #2563eb 50%, #dc2626 100%);
    }

    .light-theme input[type="range"]::-webkit-slider-thumb {
      background: #ffffff;
      border-color: #059669;
    }

    .control-container {
      background-color: #2d2d2d;
      padding: 20px;
      border-radius: 12px;
      margin: 20px 0;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    .light-theme .control-container {
      background-color: #f8fafc;
    }

    .controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 15px;
      margin-top: 20px;
    }

    .token-buttons {
      display: flex;
      gap: 10px;
      justify-content: space-between;
      width: 100%;
    }

    .add-token-btn, .remove-token-btn {
      flex: 1;
      min-width: 0;
    }

    .add-token-btn {
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
    }

    .add-token-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 6px rgba(16, 185, 129, 0.2);
    }

    .remove-token-btn {
      background: linear-gradient(135deg, #ef4444, #dc2626);
      color: white;
    }

    .remove-token-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 6px rgba(239, 68, 68, 0.2);
    }

    .refresh-btn {
      background: linear-gradient(135deg, #3b82f6, #2563eb);
      color: white;
    }

    .refresh-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 6px rgba(59, 130, 246, 0.2);
    }

    .arb-btn {
      background: linear-gradient(135deg, #f59e0b, #d97706);
      color: white;
    }

    .arb-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 6px rgba(245, 158, 11, 0.2);
    }

    .token-header {
      cursor: pointer;
      user-select: none;
      position: relative;
    }
    
    .token-header:hover {
      /* background-color: #404040 !important; */
    }
    
    .token-header::after {
      content: attr(data-sort-icon);
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
    }

    .table-caption {
      text-align: right;
      color: #9ca3af;
      font-size: 11px;
      margin-top: 4px;
      font-style: italic;
    }

    .light-theme .table-caption {
      color: #6b7280;
    }

    /* Стилі для таблиці 5 */
    #orderbook-table {
      position: relative;
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      table-layout: fixed;
      border-radius: 8px;
      overflow: hidden;
    }

    #orderbook-table thead,
    #orderbook-table tbody {
      display: block;
    }

    #orderbook-table tbody {
      height: calc(53px * 5.625);
      overflow-y: auto;
      overflow-x: hidden;
      scrollbar-width: thin;
      scrollbar-color: #444444 #1a1a1a;
    }

    #orderbook-table thead tr,
    #orderbook-table tbody tr {
      display: table;
      width: 100%;
      table-layout: fixed;
    }

    #orderbook-table thead {
      position: sticky;
      top: 0;
      z-index: 2;
      background-color: #333333;
      width: calc(100% - 4px); /* Зменшено відступ для тоншого скролбара */
    }

    #orderbook-table th,
    #orderbook-table td {
      padding: 12px 8px;
      border: 1px solid #444444;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-align: center; /* Вирівнювання по центру */
    }

    /* Фіксовані ширини для стовпців */
    #orderbook-table th:first-child,
    #orderbook-table td:first-child {
      width: 80px;
      text-align: center; /* Змінено на center */
      padding-left: 8px;
    }

    #orderbook-table th:nth-child(2),
    #orderbook-table td:nth-child(2) {
      width: 60px;
      text-align: center;
    }

    #orderbook-table th:not(:first-child):not(:nth-child(2)),
    #orderbook-table td:not(:first-child):not(:nth-child(2)) {
      width: calc((100% - 140px) / var(--exchange-count, 3));
      text-align: center; /* Змінено на center */
      padding-right: 8px;
    }

    /* Стилі для скролбара */
    #orderbook-table tbody::-webkit-scrollbar {
      width: 4px; /* Тонший скролбар */
    }

    #orderbook-table tbody::-webkit-scrollbar-track {
      background: #1a1a1a;
      border-radius: 2px;
    }

    #orderbook-table tbody::-webkit-scrollbar-thumb {
      background: #444444;
      border-radius: 2px;
    }

    #orderbook-table tbody::-webkit-scrollbar-thumb:hover {
      background: #555555;
    }

    /* Стилі для світлої теми */
    .light-theme #orderbook-table thead {
      background-color: #f3f4f6;
    }

    .light-theme #orderbook-table tbody::-webkit-scrollbar-track {
      background: #f0f2f5;
    }

    .light-theme #orderbook-table tbody::-webkit-scrollbar-thumb {
      background: #d1d5db;
    }

    .light-theme #orderbook-table tbody::-webkit-scrollbar-thumb:hover {
      background: #9ca3af;
    }

    .light-theme #orderbook-table {
      border: 1px solid #e5e7eb;
    }

    .sort-header:hover {
      /* background-color: #e9ecef; */
    }

    .orderbook-table th.sort-header:hover {
      /* background-color: #e9ecef; */
    }

    .slider-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .slider-header label {
      margin: 0;
      font-weight: bold;
      color: #ffffff;
    }

    .indicator-toggle {
      padding: 0;
      width: 60px;
      height: 10px;
      border: none;
      border-radius: 10px;
      background-color: #444444;
      color: #ffffff;
      cursor: pointer;
      font-size: 100px;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .indicator-toggle:hover {
      background-color: #555555;
    }

    .indicator-toggle.active {
      background-color: #10b981;
      color: white;
      box-shadow: 0 0 5px rgba(16, 185, 129, 0.3);
    }

    .indicator-toggle.active:hover {
      background-color: #059669;
    }

    /* Стилі для світлої теми */
    .light-theme .indicator-toggle {
      background-color: #e5e7eb;
      color: #374151;
    }

    .light-theme .indicator-toggle:hover {
      background-color: #d1d5db;
    }

    .light-theme .indicator-toggle.active {
      background-color: #059669;
      color: white;
    }

    .light-theme .indicator-toggle.active:hover {
      background-color: #047857;
    }
  </style>
</head>
<body>
  <div class="status-legend">
    <h3>Статус бірж</h3>
    <div class="status-legend-items">
      <div class="status-legend-item">
        <div class="exchange-status-indicator exchange-connected"></div>
        <span>Є дані</span>
      </div>
      <div class="status-legend-item">
        <div class="exchange-status-indicator exchange-no-data"></div>
        <span>Немає даних</span>
      </div>
      <div class="status-legend-item">
        <div class="exchange-status-indicator exchange-disconnected"></div>
        <span>Відключено</span>
      </div>
    </div>
    <button id="theme-toggle" class="theme-toggle">
      <span id="theme-icon">☀️</span>
      <span id="theme-text">Світла тема</span>
    </button>
  </div>
  <div class="container">
    <div class="header-container">
      <h1>Crypto Orderbook Dashboard</h1>
      <div class="header-right">
        <div class="status">
          <div id="status-indicator" class="status-indicator disconnected"></div>
          <span id="status-text">Disconnected</span>
        </div>
      </div>
    </div>
    <div class="table-caption" style="text-align: left; margin: 20px 0 10px 0;">Група таблиць ордербуків (Таблиці 1-4)</div>
    <div class="orderbook-tables-container">
      <div class="orderbook-tables-row">
        <div class="orderbook-table-container">
          <div class="orderbook-controls">
            <div style="display: flex; gap: 10px;">
              <select class="orderbook-select" id="left-exchange-select">
                <option value="">Виберіть біржу</option>
              </select>
              <select class="orderbook-select" id="left-token-select">
                <option value="">Виберіть токен</option>
              </select>
            </div>
            <h3 class="orderbook-title">Orderbook Left</h3>
          </div>
          <div class="orderbook-content">
            <div class="orderbook-row">
              <div class="orderbook-side">
                <table class="orderbook-table" id="orderbook-left-sell-table">
                  <thead>
                    <tr>
                      <th>Price</th>
                      <th>Quantity</th>
                      <th>Sum (USDT)</th>
                      <th>Depth (USDT)</th>
                    </tr>
                  </thead>
                  <tbody id="orderbook-left-sell"></tbody>
                </table>
                <div class="table-caption">Таблиця 1 (orderbook-left-sell-table)</div>
              </div>
              <div class="orderbook-side">
                <table class="orderbook-table" id="orderbook-left-buy-table">
                  <tbody id="orderbook-left-buy"></tbody>
                  <thead>
                    <tr>
                      <th>Price</th>
                      <th>Quantity</th>
                      <th>Sum (USDT)</th>
                      <th>Depth (USDT)</th>
                    </tr>
                  </thead>
                </table>
                <div class="table-caption">Таблиця 2 (orderbook-left-buy-table)</div>
              </div>
            </div>
          </div>
        </div>
        <div class="orderbook-table-container">
          <div class="orderbook-controls">
            <div style="display: flex; gap: 10px;">
              <select class="orderbook-select" id="right-exchange-select">
                <option value="">Виберіть біржу</option>
              </select>
              <select class="orderbook-select" id="right-token-select">
                <option value="">Виберіть токен</option>
              </select>
            </div>
            <h3 class="orderbook-title">Orderbook Right</h3>
          </div>
          <div class="orderbook-content">
            <div class="orderbook-row">
              <div class="orderbook-side">
                <table class="orderbook-table" id="orderbook-right-sell-table">
                  <thead>
                    <tr>
                      <th>Price</th>
                      <th>Quantity</th>
                      <th>Sum (USDT)</th>
                      <th>Depth (USDT)</th>
                    </tr>
                  </thead>
                  <tbody id="orderbook-right-sell"></tbody>
                </table>
                <div class="table-caption">Таблиця 3 (orderbook-right-sell-table)</div>
              </div>
              <div class="orderbook-side">
                <table class="orderbook-table" id="orderbook-right-buy-table">
                  <tbody id="orderbook-right-buy"></tbody>
                  <thead>
                    <tr>
                      <th>Price</th>
                      <th>Quantity</th>
                      <th>Sum (USDT)</th>
                      <th>Depth (USDT)</th>
                    </tr>
                  </thead>
                </table>
                <div class="table-caption">Таблиця 4 (orderbook-right-buy-table)</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="control-container">
      <div class="controls">
        <div class="control-group">
          <div class="input-controls">
            <input type="text" id="token-input" class="token-input" placeholder="Введіть назву токена для пошуку або додавання..." pattern="[A-Za-z0-9]+" title="Тільки літери англійського алфавіту та цифри">
            <div class="token-buttons">
              <button id="add-token-btn" class="add-token-btn">Додати токен</button>
              <button id="remove-token-btn" class="remove-token-btn">Видалити токен</button>
            </div>
          </div>
          <div class="threshold-controls">
            <div class="threshold-group">
              <div class="slider-header">
                <label for="percent-threshold">Percent Threshold:</label>
                <button id="percent-toggle" class="indicator-toggle"></button>
              </div>
              <input id="percent-threshold" type="range" min="0.1" max="10" step="0.1" value="2.0">
              <div class="threshold-value"><span id="percent-value">2.0</span>%</div>
            </div>
            <div class="threshold-group">
              <div class="slider-header">
                <label for="delta-threshold">Delta Threshold (USDT):</label>
                <button id="delta-toggle" class="indicator-toggle"></button>
              </div>
              <input id="delta-threshold" type="range" min="0.1" max="5" step="0.1" value="0.5">
              <div class="threshold-value">$<span id="delta-value">0.5</span></div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="table-caption" style="text-align: left; margin: 20px 0 10px 0;">Таблиця 5 (orderbook-table)</div>
    <div class="orderbook-tables-container">
      <table id="orderbook-table">
        <thead>
          <tr>
            <th>Token</th>
            <th>Type</th>
            <th id="exchanges-header">Loading...</th>
          </tr>
        </thead>
        <tbody id="orderbook-body">
          <tr>
            <td colspan="3">Loading data...</td>
          </tr>
        </tbody>
      </table>
    </div>
    <div id="opportunities" class="opportunities hidden">
      <h2>Arbitrage Opportunities</h2>
      <div id="opportunities-list"></div>
    </div>
  </div>
  <div class="toast-container" id="toastContainer"></div>

  <script>
    // WebSocket URL
    const WS_URL = 'ws://localhost:8000/ws';
    let socket = null;
    let reconnectTimeout = null;
    let reconnectAttempts = 0;
    let maxReconnectAttempts = 10;

    // Дані ордербуку, токени, біржі
    let tokens = [];
    let exchanges = [];
    let orderbooks = {};
    let isAscending = true;

    // Глобальні DOM елементи
    let leftExchangeSelect, leftTokenSelect, rightExchangeSelect, rightTokenSelect;

    // DOM елементи
    const percentThresholdInput = document.getElementById('percent-threshold');
    const deltaThresholdInput = document.getElementById('delta-threshold');
    const percentValueText = document.getElementById('percent-value');
    const deltaValueText = document.getElementById('delta-value');
    const opportunitiesSection = document.getElementById('opportunities');
    const opportunitiesList = document.getElementById('opportunities-list');

    // Додаємо змінні для стану кнопок
    let isPercentActive = localStorage.getItem('isPercentActive') === 'true';
    let isDeltaActive = localStorage.getItem('isDeltaActive') === 'true';

    // Оновлюємо початковий стан кнопок та бігунків
    document.addEventListener('DOMContentLoaded', function() {
        const percentToggle = document.getElementById('percent-toggle');
        const deltaToggle = document.getElementById('delta-toggle');
        const percentThreshold = document.getElementById('percent-threshold');
        const deltaThreshold = document.getElementById('delta-threshold');

        // Встановлюємо початковий стан кнопок
        if (isPercentActive) {
            percentToggle.classList.add('active');
            percentThreshold.disabled = false;
        } else {
            percentToggle.classList.remove('active');
            percentThreshold.disabled = true;
        }

        if (isDeltaActive) {
            deltaToggle.classList.add('active');
            deltaThreshold.disabled = false;
        } else {
            deltaToggle.classList.remove('active');
            deltaThreshold.disabled = true;
        }

        // Встановлюємо збережені значення бігунків
        const savedPercentThreshold = localStorage.getItem('percentThreshold');
        const savedDeltaThreshold = localStorage.getItem('deltaThreshold');
        
        if (savedPercentThreshold) {
            percentThreshold.value = savedPercentThreshold;
            document.getElementById('percent-value').textContent = savedPercentThreshold;
        }
        
        if (savedDeltaThreshold) {
            deltaThreshold.value = savedDeltaThreshold;
            document.getElementById('delta-value').textContent = savedDeltaThreshold;
        }
    });

    // Додаємо обробники для кнопок
    document.getElementById('percent-toggle').addEventListener('click', function() {
      isPercentActive = !isPercentActive;
      localStorage.setItem('isPercentActive', isPercentActive);
      this.classList.toggle('active');
      const percentThreshold = document.getElementById('percent-threshold');
      percentThreshold.disabled = !isPercentActive;
      // Оновлюємо підсвічування при зміні стану
      analyzeAndUpdateAllCells();
    });

    document.getElementById('delta-toggle').addEventListener('click', function() {
      isDeltaActive = !isDeltaActive;
      localStorage.setItem('isDeltaActive', isDeltaActive);
      this.classList.toggle('active');
      const deltaThreshold = document.getElementById('delta-threshold');
      deltaThreshold.disabled = !isDeltaActive;
      // Оновлюємо підсвічування при зміні стану
      analyzeAndUpdateAllCells();
    });

    // Оновлюємо обробники для полів вводу
    document.getElementById('percent-threshold').addEventListener('input', function() {
      const newValue = parseFloat(this.value);
      if (!isNaN(newValue)) {
        localStorage.setItem('percentThreshold', newValue);
        document.getElementById('percent-value').textContent = newValue.toFixed(1);
        // Оновлюємо підсвічування при зміні значення
        analyzeAndUpdateAllCells();
      }
    });
    
    document.getElementById('delta-threshold').addEventListener('input', function() {
      const newValue = parseFloat(this.value);
      if (!isNaN(newValue)) {
        localStorage.setItem('deltaThreshold', newValue);
        document.getElementById('delta-value').textContent = newValue.toFixed(1);
        // Оновлюємо підсвічування при зміні значення
        analyzeAndUpdateAllCells();
      }
    });

    function connect() {
      socket = new WebSocket(WS_URL);
      socket.onopen = () => {
        console.log('WebSocket connected');
        setConnectionStatus(true);
        reconnectAttempts = 0;
      };
      socket.onclose = (event) => {
        console.log(`WebSocket closed: ${event.code} - ${event.reason}`);
        setConnectionStatus(false);
        scheduleReconnect();
      };
      socket.onerror = (error) => {
        console.error('WebSocket error:', error);
      };
      socket.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          console.log('Отримано повідомлення:', message);
          if (message.type === 'orderbook_update') {
            console.log('Дані orderbook_update:', {
              exchange: message.exchange,
              token: message.token,
              best_sell: message.data?.best_sell,
              best_buy: message.data?.best_buy
            });
          }
          handleMessage(message);
        } catch (error) {
          console.error('Error parsing message:', error);
        }
      };
    }

    function scheduleReconnect() {
      if (reconnectTimeout) clearTimeout(reconnectTimeout);
      if (reconnectAttempts < maxReconnectAttempts) {
        reconnectAttempts++;
        const delay = 2000 * Math.pow(1.5, reconnectAttempts - 1);
        console.log(`Reconnecting in ${delay/1000} seconds (attempt ${reconnectAttempts}/${maxReconnectAttempts})`);
        reconnectTimeout = setTimeout(() => { connect(); }, delay);
      } else {
        console.error('Max reconnect attempts reached');
      }
    }

    function setConnectionStatus(isConnected) {
      const indicator = document.getElementById('status-indicator');
      const text = document.getElementById('status-text');
      if (isConnected) {
        indicator.classList.remove('disconnected');
        indicator.classList.add('connected');
        text.textContent = 'Connected';
      } else {
        indicator.classList.remove('connected');
        indicator.classList.add('disconnected');
        text.textContent = 'Disconnected';
      }
    }

    function handleMessage(message) {
      const type = message.type;
      console.log('Received message type:', type);
      switch (type) {
        case 'initial_data':
          tokens = message.tokens || [];
          exchanges = message.exchanges.map(e => e.name) || [];
          orderbooks = message.orderbooks || {};
          window.lastData = { tokens, exchanges, orderbooks };
          updateTokenFilter();
          updateExchangeSelects();
          updateTokenSelects();
          renderTable();
          break;
        case 'orderbook_update':
          console.log("orderbook_update received:", JSON.stringify(message, null, 2));
          const { exchange: exchangeName, token: tokenName, best_sell, best_buy } = message;
          console.log(`Updating prices for ${tokenName} on ${exchangeName}: sell=${best_sell}, buy=${best_buy}`);
          updateOrderbook(message);
          break;
        case 'orderbook_data':
          console.log("orderbook_data received:", JSON.stringify(message, null, 2));
          const { token, exchange, data } = message;
          console.log('Processing orderbook data:', { token, exchange, data });
          
          if (!data || !data.asks || !data.bids) {
              console.error('Invalid orderbook data format:', data);
              return;
          }
          
          const asks = data.asks;
          const bids = data.bids;
          
          console.log('Orders to display:', { 
              asks_count: asks.length, 
              bids_count: bids.length 
          });
          
          // Визначення, яка таблиця (ліва чи права) оновлюється
          const isRightClick = document.querySelector('.orderbook-table-container:last-child')
                                  .querySelector('.orderbook-title').textContent.includes(token);
          
          if (isRightClick) {
              fillOrderbookTable(document.getElementById('orderbook-right-sell'), asks, true);
              fillOrderbookTable(document.getElementById('orderbook-right-buy'), bids, false);
              // Встановлюємо скрол для sell таблиці в нижню позицію
              const sellTable = document.getElementById('orderbook-right-sell');
              sellTable.scrollTop = sellTable.scrollHeight;
          } else {
              fillOrderbookTable(document.getElementById('orderbook-left-sell'), asks, true);
              fillOrderbookTable(document.getElementById('orderbook-left-buy'), bids, false);
              // Встановлюємо скрол для sell таблиці в нижню позицію
              const sellTable = document.getElementById('orderbook-left-sell');
              sellTable.scrollTop = sellTable.scrollHeight;
          }
          break;
        case 'token_added':
          tokens.push(message.token);
          updateTokenFilter();
          renderTable();
          showToast(`Токен ${message.token} успішно додано`, 'success');
          break;
        case 'token_removed':
          tokens = tokens.filter(t => t !== message.token);
          updateTokenFilter();
          renderTable();
          showToast(`Токен ${message.token} успішно видалено`, 'success');
          break;
        case 'exchange_added':
          exchanges.push(message.exchange.name);
          renderTable();
          break;
        case 'exchange_removed':
          exchanges = exchanges.filter(e => e !== message.exchange);
          renderTable();
          break;
        case 'orderbooks_cleared':
          orderbooks = {};
          renderTable();
          break;
        case 'full_table_update':
          orderbooks = message.data;
          renderTable();
          break;
        case 'error':
          console.error('Server error:', message.message);
          showToast(message.message, 'error');
          break;
        default:
          console.warn('Unknown message type:', type);
          break;
      }
    }

    function updateTokenFilter() {
      renderTable();
    }

    function updateOrderbook(data) {
      const { exchange, token, best_sell, best_buy } = data;
      if (!orderbooks[token]) orderbooks[token] = {};
      
      // Перевіряємо, чи змінилися значення
      const currentOrderbook = orderbooks[token][exchange] || {};
      if (currentOrderbook.best_sell !== best_sell || currentOrderbook.best_buy !== best_buy) {
        orderbooks[token][exchange] = { best_sell, best_buy };
        
        // Оновлюємо тільки ті клітинки, які змінилися
        if (currentOrderbook.best_sell !== best_sell) {
          updateTableCell(token, exchange, 'sell', best_sell);
        }
        if (currentOrderbook.best_buy !== best_buy) {
          updateTableCell(token, exchange, 'buy', best_buy);
        }

        // Аналізуємо всю таблицю після оновлення
        analyzeAndUpdateAllCells();
      }
    }

    function analyzeAndUpdateAllCells() {
      const analysis = analyzeAllValues();
      
      // Оновлюємо підсвічування для всіх клітинок
      for (const token in analysis) {
        for (const cellKey in analysis[token]) {
          const [exchange, type] = cellKey.split('-');
          const cell = document.getElementById(`${token}-${exchange}-${type}`);
          if (cell) {
            cell.classList.remove('highlight-green', 'highlight-red');
            if (analysis[token][cellKey] === 'green') {
              cell.classList.add('highlight-green');
            } else if (analysis[token][cellKey] === 'red') {
              cell.classList.add('highlight-red');
            }
          }
        }
      }
    }

    function calculatePercent(value1, value2) {
      return ((value1 - value2) / value2) * 100;
    }
    function calculateDelta(value1, value2) {
      return value1 - value2;
    }
    function analyzeAllValues() {
      const analysis = {};
      
      // Перевіряємо, чи активні бігунки
      const isPercentActive = document.getElementById('percent-toggle').classList.contains('active');
      const isDeltaActive = document.getElementById('delta-toggle').classList.contains('active');
      
      // Якщо обидва бігунки неактивні, не аналізуємо
      if (!isPercentActive && !isDeltaActive) return analysis;

      const percentThreshold = parseFloat(document.getElementById('percent-threshold').value);
      const deltaThreshold = parseFloat(document.getElementById('delta-threshold').value);

      // Аналізуємо всі значення
      for (const token of tokens) {
        analysis[token] = {};
        
        // Збираємо всі валідні значення для токена
        const validValues = {
          sell: {},
          buy: {}
        };
        
        for (const exchange of exchanges) {
          if (!orderbooks[token] || !orderbooks[token][exchange]) continue;
          
          const sellValue = orderbooks[token][exchange].best_sell;
          const buyValue = orderbooks[token][exchange].best_buy;
          
          if (sellValue !== 'X X X') {
            const sellValueFloat = parseFloat(sellValue);
            if (!isNaN(sellValueFloat)) {
              validValues.sell[exchange] = sellValueFloat;
            }
          }
          
          if (buyValue !== 'X X X') {
            const buyValueFloat = parseFloat(buyValue);
            if (!isNaN(buyValueFloat)) {
              validValues.buy[exchange] = buyValueFloat;
            }
          }
        }
        
        // Аналізуємо кожну біржу
        for (const exchange of exchanges) {
          if (!orderbooks[token] || !orderbooks[token][exchange]) continue;
          
          const sellValue = orderbooks[token][exchange].best_sell;
          const buyValue = orderbooks[token][exchange].best_buy;
          
          if (sellValue === 'X X X' || buyValue === 'X X X') continue;
          
          const sellValueFloat = parseFloat(sellValue);
          const buyValueFloat = parseFloat(buyValue);
          
          if (isNaN(sellValueFloat) || isNaN(buyValueFloat)) continue;
          
          // Перевіряємо всі можливі пари бірж
          for (const [otherExchange, otherBuyValue] of Object.entries(validValues.buy)) {
            if (otherExchange === exchange) continue;
            
            const sellPercent = ((otherBuyValue - sellValueFloat) / sellValueFloat) * 100;
            const sellDelta = otherBuyValue - sellValueFloat;
            
            if ((isPercentActive && sellPercent >= percentThreshold) || 
                (isDeltaActive && sellDelta >= deltaThreshold)) {
              // Підсвічуємо обидві клітинки
              analysis[token][`${exchange}-sell`] = 'green';
              analysis[token][`${otherExchange}-buy`] = 'red';
            }
          }
          
          // Перевіряємо інші біржі для buy ціни
          for (const [otherExchange, otherSellValue] of Object.entries(validValues.sell)) {
            if (otherExchange === exchange) continue;
            
            const buyPercent = ((buyValueFloat - otherSellValue) / otherSellValue) * 100;
            const buyDelta = buyValueFloat - otherSellValue;
            
            if ((isPercentActive && buyPercent >= percentThreshold) || 
                (isDeltaActive && buyDelta >= deltaThreshold)) {
              // Підсвічуємо обидві клітинки
              analysis[token][`${exchange}-buy`] = 'red';
              analysis[token][`${otherExchange}-sell`] = 'green';
            }
          }
        }
      }
      
      return analysis;
    }

    function updateTableCell(token, exchange, type, value) {
      const cell = document.getElementById(`${token}-${exchange}-${type}`);
      if (cell) {
        const oldValue = cell.textContent;
        if (oldValue !== value) {
          cell.textContent = value;
          updateCellHighlighting(cell, token, exchange, type, value);
        }
      }
    }

    function updateCellHighlighting(cell, token, exchange, type, value) {
      // Видаляємо попередні класи підсвічування
      cell.classList.remove('highlight-green', 'highlight-red');
      
      // Перевіряємо базові умови
      if (value === 'X X X' || exchanges.length < 2) return;
      const currentValue = parseFloat(value);
      if (isNaN(currentValue)) return;

      // Отримуємо результат аналізу
      const analysis = analyzeAllValues();
      const highlightType = analysis[token]?.[`${exchange}-${type}`];
      
      // Застосовуємо підсвічування тільки якщо воно вказано в аналізі
      if (highlightType === 'green') {
        cell.classList.add('highlight-green');
      } else if (highlightType === 'red') {
        cell.classList.add('highlight-red');
      }
    }

    // Додаємо функцію сортування до глобального об'єкту
    window.handleSort = function() {
      isAscending = !isAscending;
      const tokenHeader = document.querySelector('.token-header');
      if (tokenHeader) {
        tokenHeader.setAttribute('data-sort-icon', isAscending ? '↑' : '↓');
      }
      
      const sortedTokens = [...tokens].sort((a, b) => {
        return isAscending ? a.localeCompare(b) : b.localeCompare(a);
      });
      
      const tableBody = document.getElementById('orderbook-body');
      tableBody.innerHTML = '';
      
      sortedTokens.forEach(token => {
        // Рядок для Sell
        const sellRow = document.createElement('tr');
        sellRow.innerHTML = `
          <td rowspan="2" class="token-cell">${token}</td>
          <td class="type-cell">Sell</td>
          ${exchanges.map(exchange => `
            <td id="${token}-${exchange}-sell" class="sell-price">
              ${orderbooks[token]?.[exchange]?.best_sell || 'X X X'}
            </td>
          `).join('')}
        `;
        tableBody.appendChild(sellRow);
        
        // Рядок для Buy
        const buyRow = document.createElement('tr');
        buyRow.innerHTML = `
          <td rowspan="2" class="token-cell">${token}</td>
          <td class="type-cell">Buy</td>
          ${exchanges.map(exchange => `
            <td id="${token}-${exchange}-buy" class="buy-price">
              ${orderbooks[token]?.[exchange]?.best_buy || 'X X X'}
            </td>
          `).join('')}
        `;
        tableBody.appendChild(buyRow);
      });
    };

    // Оновлення таблиці ордербуку (створення рядків)
    function renderTable() {
      const filteredTokens = tokens;
      
      // Перевіряємо чи існує елемент exchanges-header
      let exchangesHeader = document.getElementById('exchanges-header');
      if (!exchangesHeader) {
        // Створюємо новий елемент, якщо він відсутній
        exchangesHeader = document.createElement('th');
        exchangesHeader.id = 'exchanges-header';
        const headerRow = document.querySelector('#orderbook-table thead tr');
        if (headerRow) {
          headerRow.appendChild(exchangesHeader);
        } else {
          console.error('Header row not found');
          return;
        }
      }

      const headerRow = exchangesHeader.parentElement;
      if (!headerRow) {
        console.error('Parent element of exchanges-header not found');
        return;
      }

      headerRow.innerHTML = `
        <th class="token-header" onclick="handleSort()" data-sort-icon="${isAscending ? '↑' : '↓'}">Token</th>
        <th>Type</th>
        ${exchanges.map(exchange => `<th>${exchange}</th>`).join('')}
      `;
      
      window.handleSort();
    }

    // Функція для заповнення таблиці ордербуку
    function fillOrderbookTable(tbody, orders, isSell) {
        console.log('Filling orderbook table:', { tbody, orders, isSell });
        
        if (!tbody || !orders || !Array.isArray(orders)) {
            console.error('Invalid parameters for fillOrderbookTable:', { tbody, orders, isSell });
            return;
        }

        // Очищаємо таблицю
        tbody.innerHTML = '';

        // Сортуємо ордери
        const sortedOrders = [...orders].sort((a, b) => {
            const priceA = parseFloat(a[0]);
            const priceB = parseFloat(b[0]);
            return isSell ? priceB - priceA : priceA - priceB;
        });

        // Якщо це бай ордери, реверсуємо масив
        if (!isSell) {
            sortedOrders.reverse();
        }

        console.log('Sorted orders:', sortedOrders);

        // Розраховуємо загальний об'єм для глибини
        let totalVolume = 0;
        sortedOrders.forEach(order => {
            totalVolume += parseFloat(order[1]) * parseFloat(order[0]);
        });

        console.log('Total volume:', totalVolume);

        // Заповнюємо таблицю
        let currentVolume = 0;
        // Для селл ордерів рахуємо глибину від найнижчої ціни до найвищої
        if (isSell) {
            // Спочатку розраховуємо глибину від найнижчої ціни
            let depthVolume = 0;
            for (let i = sortedOrders.length - 1; i >= 0; i--) {
                const order = sortedOrders[i];
                const price = parseFloat(order[0]);
                const amount = parseFloat(order[1]);
                const total = price * amount;
                depthVolume += total;
            }

            // Тепер відображаємо ордери з найвищої ціни до найнижчої
            for (let i = 0; i < sortedOrders.length; i++) {
                const order = sortedOrders[i];
                const price = parseFloat(order[0]);
                const amount = parseFloat(order[1]);
                const total = price * amount;
                currentVolume += total;

                // Визначаємо кількість знаків після коми для ціни
                let priceDecimals = 8;
                if (price >= 1000) priceDecimals = 2;
                else if (price >= 100) priceDecimals = 3;
                else if (price >= 10) priceDecimals = 4;
                else if (price >= 1) priceDecimals = 5;
                else if (price >= 0.1) priceDecimals = 6;
                else if (price >= 0.01) priceDecimals = 7;

                const row = document.createElement('tr');
                row.className = isSell ? 'sell' : 'buy';

                row.innerHTML = `
                    <td class="${isSell ? 'sell-price' : 'buy-price'}">${price.toFixed(priceDecimals)}</td>
                    <td class="amount">${amount.toFixed(8)}</td>
                    <td class="total">${total.toFixed(2)}</td>
                    <td class="depth">${(depthVolume - currentVolume + total).toFixed(2)}</td>
                `;

                tbody.appendChild(row);
            }
        } else {
            sortedOrders.forEach(order => {
                const price = parseFloat(order[0]);
                const amount = parseFloat(order[1]);
                const total = price * amount;
                currentVolume += total;

                // Визначаємо кількість знаків після коми для ціни
                let priceDecimals = 8;
                if (price >= 1000) priceDecimals = 2;
                else if (price >= 100) priceDecimals = 3;
                else if (price >= 10) priceDecimals = 4;
                else if (price >= 1) priceDecimals = 5;
                else if (price >= 0.1) priceDecimals = 6;
                else if (price >= 0.01) priceDecimals = 7;

                const row = document.createElement('tr');
                row.className = isSell ? 'sell' : 'buy';

                row.innerHTML = `
                    <td class="${isSell ? 'sell-price' : 'buy-price'}">${price.toFixed(priceDecimals)}</td>
                    <td class="amount">${amount.toFixed(8)}</td>
                    <td class="total">${total.toFixed(2)}</td>
                    <td class="depth">${currentVolume.toFixed(2)}</td>
                `;

                tbody.appendChild(row);
            });
        }

        console.log('Table filled with orders');
    }

    // Функція для оновлення ордербуків
    function updateOrderbooks(token, exchange, isRightClick = false) {
        console.log('Updating orderbooks:', { token, exchange, isRightClick });
        
        // Визначаємо яку таблицю оновлювати
        const targetContainer = isRightClick ? 
            document.querySelector('.orderbook-table-container:last-child') : 
            document.querySelector('.orderbook-table-container:first-child');

        // Очищаємо тільки таблиці в цьому контейнері
        const targetTbody = targetContainer.querySelectorAll('.orderbook-table tbody');
        targetTbody.forEach(tbody => {
            tbody.innerHTML = '<tr><td colspan="3">Немає даних</td></tr>';
        });

        // Очищаємо заголовок тільки цієї таблиці
        const title = targetContainer.querySelector('.orderbook-title');
        title.textContent = `Orderbook ${token} - ${exchange}`;

        // Оновлюємо значення в комбобоксах
        if (isRightClick) {
            rightExchangeSelect.value = exchange;
            rightTokenSelect.value = token;
        } else {
            leftExchangeSelect.value = exchange;
            leftTokenSelect.value = token;
        }

        // Отримуємо дані з бекенду
        if (socket && socket.readyState === WebSocket.OPEN) {
            console.log('Sending get_orderbook request:', { token, exchange });
            socket.send(JSON.stringify({
                action: 'get_orderbook',
                token: token,
                exchange: exchange
            }));
        } else {
            console.error('WebSocket is not connected');
        }
    }

    // Додаємо обробники кліків до клітинок таблиці
    document.addEventListener('DOMContentLoaded', function() {
        // Ініціалізуємо глобальні DOM елементи
        leftExchangeSelect = document.getElementById('left-exchange-select');
        leftTokenSelect = document.getElementById('left-token-select');
        rightExchangeSelect = document.getElementById('right-exchange-select');
        rightTokenSelect = document.getElementById('right-token-select');

        // Оновлюємо комбобокси початковими даними, якщо вони вже є
        if (exchanges.length > 0) {
            updateExchangeSelects();
        }
        if (tokens.length > 0) {
            updateTokenSelects();
        }
        
        // Додаємо обробники подій для комбобоксів
        leftExchangeSelect.addEventListener('change', function() {
            const token = leftTokenSelect.value;
            if (token && this.value) updateOrderbooks(token, this.value, false);
        });
        
        leftTokenSelect.addEventListener('change', function() {
            const exchange = leftExchangeSelect.value;
            if (exchange && this.value) updateOrderbooks(this.value, exchange, false);
        });
        
        rightExchangeSelect.addEventListener('change', function() {
            const token = rightTokenSelect.value;
            if (token && this.value) updateOrderbooks(token, this.value, true);
        });
        
        rightTokenSelect.addEventListener('change', function() {
            const exchange = rightExchangeSelect.value;
            if (exchange && this.value) updateOrderbooks(this.value, exchange, true);
        });
        
        // Додаємо обробники кліків для основної таблиці
        const orderbookBody = document.getElementById('orderbook-body');
        
        orderbookBody.addEventListener('click', function(e) {
            const cell = e.target.closest('td');
            if (!cell) return;
            
            const parts = cell.id.split('-');
            if (parts.length !== 3) return;
            
            const [token, exchange] = parts;
            if (!token || !exchange) return;
            
            leftExchangeSelect.value = exchange;
            leftTokenSelect.value = token;
            
            updateOrderbooks(token, exchange, false);
        });

        orderbookBody.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            
            const cell = e.target.closest('td');
            if (!cell) return;
            
            const parts = cell.id.split('-');
            if (parts.length !== 3) return;
            
            const [token, exchange] = parts;
            if (!token || !exchange) return;
            
            rightExchangeSelect.value = exchange;
            rightTokenSelect.value = token;
            
            updateOrderbooks(token, exchange, true);
        });
    });

    // Функції оновлення комбобоксів
    function updateExchangeSelects() {
        if (!leftExchangeSelect || !rightExchangeSelect) return;
        const exchangeOptions = exchanges.map(exchange => `<option value="${exchange}">${exchange}</option>`).join('');
        leftExchangeSelect.innerHTML = '<option value="">Виберіть біржу</option>' + exchangeOptions;
        rightExchangeSelect.innerHTML = '<option value="">Виберіть біржу</option>' + exchangeOptions;
    }

    function updateTokenSelects() {
        if (!leftTokenSelect || !rightTokenSelect) return;
        const tokenOptions = tokens.map(token => `<option value="${token}">${token}</option>`).join('');
        leftTokenSelect.innerHTML = '<option value="">Виберіть токен</option>' + tokenOptions;
        rightTokenSelect.innerHTML = '<option value="">Виберіть токен</option>' + tokenOptions;
    }

    function refreshPrices() {
      if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ action: 'update_prices' }));
      }
    }
    function findArbitrageOpportunities() {
      // Реалізація пошуку арбітражу
      console.log("Searching arbitrage opportunities...");
    }

    // Додаємо функціонал перемикання теми
    const themeToggle = document.getElementById('theme-toggle');
    const themeIcon = document.getElementById('theme-icon');
    const themeText = document.getElementById('theme-text');
    
    themeToggle.addEventListener('click', () => {
      document.body.classList.toggle('light-theme');
      if (document.body.classList.contains('light-theme')) {
        themeIcon.textContent = '🌙';
        themeText.textContent = 'Темна тема';
      } else {
        themeIcon.textContent = '☀️';
        themeText.textContent = 'Світла тема';
      }
    });

    // Додаємо обробник для поля вводу
    const tokenInput = document.getElementById('token-input');

    // Пошук при введенні
    tokenInput.addEventListener('input', function() {
      const searchTerm = this.value.trim().toUpperCase();
      filterTable(searchTerm);
    });

    // Функція для показу спливаючих повідомлень
    function showToast(message, type = 'success') {
      const toastContainer = document.getElementById('toastContainer');
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.textContent = message;
      
      toastContainer.appendChild(toast);
      
      // Видаляємо повідомлення через 3 секунди
      setTimeout(() => {
        toast.style.opacity = '0';
        setTimeout(() => {
          toastContainer.removeChild(toast);
        }, 300);
      }, 3000);
    }

    // Функція для відправки повідомлень через WebSocket
    function sendMessage(message) {
      if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify(message));
        return true;
      }
      showToast('Немає з\'єднання з сервером', 'error');
      return false;
    }

    // Оновлюємо обробник для кнопки додавання токену
    document.getElementById('add-token-btn').addEventListener('click', function() {
      const newToken = tokenInput.value.trim().toUpperCase();
      
      if (!newToken) {
        showToast('Будь ласка, введіть назву токену', 'error');
        return;
      }
      
      if (!/^[A-Z0-9]+$/.test(newToken)) {
        showToast('Назва токену повинна містити тільки літери англійського алфавіту та цифри', 'error');
        return;
      }
      
      if (tokens.includes(newToken)) {
        showToast('Цей токен вже додано', 'error');
        return;
      }
      
      if (sendMessage({
        action: 'add_token',
        token: newToken
      })) {
        tokenInput.value = '';
      }
    });

    // Додаємо обробник для кнопки видалення токену
    document.getElementById('remove-token-btn').addEventListener('click', function() {
      const tokenToRemove = tokenInput.value.trim().toUpperCase();
      
      if (!tokenToRemove) {
        showToast('Будь ласка, введіть назву токену для видалення', 'error');
        return;
      }
      
      if (!tokens.includes(tokenToRemove)) {
        showToast('Такого токену не існує', 'error');
        return;
      }
      
      if (sendMessage({
        action: 'remove_token',
        token: tokenToRemove
      })) {
        // Видаляємо токен з локального масиву
        tokens = tokens.filter(t => t !== tokenToRemove);
        
        // Оновлюємо фільтр токенів
        updateTokenFilter();
        
        // Оновлюємо селекти з токенами
        updateTokenSelects();
        
        // Оновлюємо таблицю
        renderTable();
        
        // Очищаємо поле вводу
        tokenInput.value = '';
      }
    });

    // Функція фільтрації таблиці
    function filterTable(searchTerm) {
      const rows = document.querySelectorAll('#orderbook-body tr');
      
      rows.forEach(row => {
        const tokenCell = row.querySelector('.token-cell');
        if (!tokenCell) return;
        
        const token = tokenCell.textContent;
        const shouldShow = token.includes(searchTerm);
        
        const nextRow = row.nextElementSibling;
        
        if (shouldShow) {
          row.style.display = '';
          if (nextRow) nextRow.style.display = '';
          row.classList.add('highlight-row');
          if (nextRow) nextRow.classList.add('highlight-row');
        } else {
          row.style.display = 'none';
          if (nextRow) nextRow.style.display = 'none';
          row.classList.remove('highlight-row');
          if (nextRow) nextRow.classList.remove('highlight-row');
        }
      });
    }

    // Додаємо нову функцію для аналізу таблиць 1-4
    function analyzeOrderbookTables() {
      const isPercentActive = document.getElementById('percent-toggle').classList.contains('active');
      const isDeltaActive = document.getElementById('delta-toggle').classList.contains('active');
      
      if (!isPercentActive && !isDeltaActive) return;

      const percentThreshold = parseFloat(document.getElementById('percent-threshold').value);
      const deltaThreshold = parseFloat(document.getElementById('delta-threshold').value);

      // Отримуємо дані з таблиць
      const leftSellTable = document.getElementById('orderbook-left-sell');
      const leftBuyTable = document.getElementById('orderbook-left-buy');
      const rightSellTable = document.getElementById('orderbook-right-sell');
      const rightBuyTable = document.getElementById('orderbook-right-buy');

      if (!leftSellTable || !leftBuyTable || !rightSellTable || !rightBuyTable) return;

      // Отримуємо всі рядки з таблиць
      const leftSellRows = leftSellTable.querySelectorAll('tr');
      const leftBuyRows = leftBuyTable.querySelectorAll('tr');
      const rightSellRows = rightSellTable.querySelectorAll('tr');
      const rightBuyRows = rightBuyTable.querySelectorAll('tr');

      // Очищаємо попереднє підсвічування
      clearOrderbookHighlights();

      // Аналізуємо кожен рядок таблиці 1 з кожним рядком таблиці 4
      let remainingBuyAmount = 0;
      let currentBuyRow = null;
      let currentBuyPrice = 0;

      rightBuyRows.forEach(rightBuyRow => {
        if (!rightBuyRow.cells || rightBuyRow.cells.length < 2) return;
        
        const rightBuyPrice = parseFloat(rightBuyRow.cells[0].textContent);
        const rightBuyAmount = parseFloat(rightBuyRow.cells[1].textContent);
        if (isNaN(rightBuyPrice) || isNaN(rightBuyAmount)) return;

        // Якщо це новий ордер на покупку
        if (currentBuyRow !== rightBuyRow) {
          currentBuyRow = rightBuyRow;
          currentBuyPrice = rightBuyPrice;
          remainingBuyAmount = rightBuyAmount;
        }

        // Якщо залишилось щось купити
        if (remainingBuyAmount > 0) {
          leftSellRows.forEach(leftSellRow => {
            const leftSellPrice = parseFloat(leftSellRow.cells[0].textContent);
            const leftSellAmount = parseFloat(leftSellRow.cells[1].textContent);
            if (isNaN(leftSellPrice) || isNaN(leftSellAmount)) return;

            const sellBuyPercent = ((rightBuyPrice - leftSellPrice) / leftSellPrice) * 100;
            const sellBuyDelta = rightBuyPrice - leftSellPrice;

            if ((isPercentActive && sellBuyPercent >= percentThreshold) || 
                (isDeltaActive && sellBuyDelta >= deltaThreshold)) {
              // Підсвічуємо тільки якщо є достатньо токенів для цього ордера
              const minAmount = Math.min(leftSellAmount, remainingBuyAmount);
              if (minAmount > 0) {
                leftSellRow.classList.add('highlight-green');
                rightBuyRow.classList.add('highlight-red');
                remainingBuyAmount -= minAmount;
              }
            }
          });
        }
      });

      // Аналізуємо кожен рядок таблиці 2 з кожним рядком таблиці 3
      let remainingSellAmount = 0;
      let currentSellRow = null;
      let currentSellPrice = 0;

      rightSellRows.forEach(rightSellRow => {
        const rightSellPrice = parseFloat(rightSellRow.cells[0].textContent);
        const rightSellAmount = parseFloat(rightSellRow.cells[1].textContent);
        if (isNaN(rightSellPrice) || isNaN(rightSellAmount)) return;

        // Якщо це новий ордер на продаж
        if (currentSellRow !== rightSellRow) {
          currentSellRow = rightSellRow;
          currentSellPrice = rightSellPrice;
          remainingSellAmount = rightSellAmount;
        }

        // Якщо залишилось щось продати
        if (remainingSellAmount > 0) {
          leftBuyRows.forEach(leftBuyRow => {
            const leftBuyPrice = parseFloat(leftBuyRow.cells[0].textContent);
            const leftBuyAmount = parseFloat(leftBuyRow.cells[1].textContent);
            if (isNaN(leftBuyPrice) || isNaN(leftBuyAmount)) return;

            const buySellPercent = ((leftBuyPrice - rightSellPrice) / rightSellPrice) * 100;
            const buySellDelta = leftBuyPrice - rightSellPrice;

            if ((isPercentActive && buySellPercent >= percentThreshold) || 
                (isDeltaActive && buySellDelta >= deltaThreshold)) {
              // Підсвічуємо тільки якщо є достатньо токенів для цього ордера
              const minAmount = Math.min(leftBuyAmount, remainingSellAmount);
              if (minAmount > 0) {
                leftBuyRow.classList.add('highlight-red');
                rightSellRow.classList.add('highlight-green');
                remainingSellAmount -= minAmount;
              }
            }
          });
        }
      });
    }

    function clearOrderbookHighlights() {
      // Очищаємо підсвічування в таблицях 1-4
      const tables = [
        'orderbook-left-sell',
        'orderbook-left-buy',
        'orderbook-right-sell',
        'orderbook-right-buy'
      ];
      
      tables.forEach(tableId => {
        const table = document.getElementById(tableId);
        if (table) {
          const rows = table.querySelectorAll('tr');
          rows.forEach(row => {
            row.classList.remove('highlight-green', 'highlight-red');
          });
        }
      });
    }

    // Оновлюємо інтервал для аналізу
    window.addEventListener('load', () => { connect(); });
    setInterval(() => {
      const isPercentActive = document.getElementById('percent-toggle').classList.contains('active');
      const isDeltaActive = document.getElementById('delta-toggle').classList.contains('active');
      
      if (isPercentActive || isDeltaActive) {
        // Очищаємо попереднє підсвічування
        clearOrderbookHighlights();
        // Аналізуємо таблиці 1-4
        analyzeOrderbookTables();
        // Аналізуємо таблицю 5
        analyzeAndUpdateAllCells();
      }
    }, 500); // Аналіз кожні 500 мс
  </script>
</body>
</html>

