<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Orderbook Dashboard</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f2f5;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            padding: 25px;
        }
        h1 {
            text-align: center;
            color: #1a1a1a;
            margin-bottom: 20px;
            font-size: 28px;
        }
        .header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }
        .status {
            display: flex;
            align-items: center;
            background-color: #f9f9f9;
            padding: 8px 15px;
            border-radius: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
        }
        .connected {
            background-color: #10b981;
            box-shadow: 0 0 5px #10b981;
        }
        .disconnected {
            background-color: #ef4444;
            box-shadow: 0 0 5px #ef4444;
        }
        .controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }
        .control-group {
            display: flex;
            gap: 10px;
        }
        button {
            padding: 10px 16px;
            background-color: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #2563eb;
        }
        .refresh-btn {
            background-color: #10b981;
        }
        .refresh-btn:hover {
            background-color: #059669;
        }
        .arb-btn {
            background-color: #f59e0b;
        }
        .arb-btn:hover {
            background-color: #d97706;
        }
        .threshold-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 8px;
        }
        .threshold-group {
            display: flex;
            flex-direction: column;
            flex: 1;
        }
        .threshold-group label {
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 14px;
        }
        .threshold-group input {
            width: 100%;
        }
        .threshold-value {
            margin-top: 5px;
            font-size: 14px;
            color: #6b7280;
            text-align: center;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        th, td {
            border: 1px solid #e5e7eb;
            padding: 12px;
            text-align: center;
        }
        th {
            background-color: #f3f4f6;
            font-weight: bold;
            color: #374151;
        }
        .token-cell {
            font-weight: bold;
            background-color: #f9fafb;
            color: #111827;
        }
        .type-cell {
            font-weight: bold;
            width: 60px;
            background-color: #f3f4f6;
        }
        .sell-price {
            color: #ef4444;
        }
        .buy-price {
            color: #10b981;
        }
        .highlight-green {
            background-color: rgba(16, 185, 129, 0.2);
            font-weight: bold;
        }
        .highlight-red {
            background-color: rgba(239, 68, 68, 0.2);
            font-weight: bold;
        }
        
        .opportunities {
            margin-top: 30px;
            padding: 15px;
            background-color: #f0f9ff;
            border-radius: 8px;
            border-left: 4px solid #3b82f6;
        }
        .opportunities h2 {
            margin-top: 0;
            font-size: 20px;
            color: #1e40af;
        }
        .opportunity-item {
            padding: 10px;
            margin-bottom: 10px;
            background-color: white;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .opportunity-profit {
            font-weight: bold;
            color: #10b981;
        }
        .hidden {
            display: none;
        }
        .exchange-status {
            display: inline-flex;
            align-items: center;
            margin-left: 5px;
        }
        .exchange-status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }
        .exchange-connected {
            background-color: #10b981;
            box-shadow: 0 0 3px #10b981;
        }
        .exchange-disconnected {
            background-color: #ef4444;
            box-shadow: 0 0 3px #ef4444;
        }
        .exchange-no-data {
            background-color: #f59e0b;
            box-shadow: 0 0 3px #f59e0b;
        }
        .status-legend {
            position: fixed;
            right: 20px;
            top: 20px;
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: 14px;
        }
        .status-legend h3 {
            margin: 0 0 10px 0;
            color: #374151;
            font-size: 16px;
        }
        .status-legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        .status-legend-item:last-child {
            margin-bottom: 0;
        }
    </style>
</head>
<body>
    <div class="status-legend">
        <h3>Статус бірж</h3>
        <div class="status-legend-item">
            <div class="exchange-status-indicator exchange-connected"></div>
            <span>Є дані</span>
        </div>
        <div class="status-legend-item">
            <div class="exchange-status-indicator exchange-no-data"></div>
            <span>Немає даних</span>
        </div>
        <div class="status-legend-item">
            <div class="exchange-status-indicator exchange-disconnected"></div>
            <span>Відключено</span>
        </div>
    </div>
    <div class="container">
        <div class="header-container">
            <h1>Crypto Orderbook Dashboard</h1>
            <div class="status">
                <div id="status-indicator" class="status-indicator disconnected"></div>
                <span id="status-text">Disconnected</span>
            </div>
        </div>
        
        <div class="threshold-controls">
            <div class="threshold-group">
                <label for="percent-threshold">Percent Threshold:</label>
                <input id="percent-threshold" type="range" min="0.1" max="10" step="0.1" value="2.0">
                <div class="threshold-value"><span id="percent-value">2.0</span>%</div>
            </div>
            <div class="threshold-group">
                <label for="delta-threshold">Delta Threshold (USDT):</label>
                <input id="delta-threshold" type="range" min="0.1" max="5" step="0.1" value="0.5">
                <div class="threshold-value">$<span id="delta-value">0.5</span></div>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <button id="refresh-btn" class="refresh-btn">Refresh Data</button>
                <button id="find-arb-btn" class="arb-btn">Find Arbitrage</button>
            </div>
            <div>
                <select id="token-filter">
                    <option value="all">All Tokens</option>
                </select>
            </div>
        </div>
        
        <table id="orderbook-table">
            <thead>
                <tr>
                    <th>Token</th>
                    <th>Type</th>
                    <th id="exchanges-header">Loading...</th>
                </tr>
            </thead>
            <tbody id="orderbook-body">
                <tr>
                    <td colspan="3">Loading data...</td>
                </tr>
            </tbody>
        </table>
        
        <div id="opportunities" class="opportunities hidden">
            <h2>Arbitrage Opportunities</h2>
            <div id="opportunities-list"></div>
        </div>
    </div>

    <script>
        // Параметри WebSocket
        const WS_URL = 'ws://localhost:8000/ws';
        let socket = null;
        let reconnectTimeout = null;
        let reconnectAttempts = 0;
        let maxReconnectAttempts = 10;
        
        // Дані ордербуків
        let tokens = [];
        let exchanges = [];
        let orderbooks = {};
        
        // Порогові значення для підсвічування
        const thresholds = {
            percentThreshold: 2.0,
            deltaThreshold: 0.5
        };
        
        // DOM елементи
        const percentThresholdInput = document.getElementById('percent-threshold');
        const deltaThresholdInput = document.getElementById('delta-threshold');
        const percentValueText = document.getElementById('percent-value');
        const deltaValueText = document.getElementById('delta-value');
        const refreshButton = document.getElementById('refresh-btn');
        const findArbButton = document.getElementById('find-arb-btn');
        const tokenFilter = document.getElementById('token-filter');
        const opportunitiesSection = document.getElementById('opportunities');
        const opportunitiesList = document.getElementById('opportunities-list');
        
        // Ініціалізація інтерфейсу
        percentThresholdInput.value = thresholds.percentThreshold;
        deltaThresholdInput.value = thresholds.deltaThreshold;
        percentValueText.textContent = thresholds.percentThreshold;
        deltaValueText.textContent = thresholds.deltaThreshold;
        
        // Обробники подій для налаштувань
        percentThresholdInput.addEventListener('input', function() {
            thresholds.percentThreshold = parseFloat(this.value);
            percentValueText.textContent = thresholds.percentThreshold;
            renderTable();
        });
        
        deltaThresholdInput.addEventListener('input', function() {
            thresholds.deltaThreshold = parseFloat(this.value);
            deltaValueText.textContent = thresholds.deltaThreshold;
            renderTable();
        });
        
        // Обробник для фільтра токенів
        tokenFilter.addEventListener('change', function() {
            renderTable();
        });
        
        // Обробник для кнопки оновлення
        refreshButton.addEventListener('click', function() {
            refreshPrices();
        });
        
        // Обробник для кнопки пошуку арбітражу
        findArbButton.addEventListener('click', function() {
            findArbitrageOpportunities();
        });
        
        // Підключення до WebSocket
        function connect() {
            socket = new WebSocket(WS_URL);
            
            socket.onopen = () => {
                console.log('WebSocket connected');
                setConnectionStatus(true);
                reconnectAttempts = 0;
            };
            
            socket.onclose = (event) => {
                console.log(`WebSocket closed: ${event.code} - ${event.reason}`);
                setConnectionStatus(false);
                scheduleReconnect();
            };
            
            socket.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
            
            socket.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    handleMessage(message);
                } catch (error) {
                    console.error('Error parsing WebSocket message:', error);
                }
            };
        }
        
        // Планування спроби переконектитись
        function scheduleReconnect() {
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
            }
            
            if (reconnectAttempts < maxReconnectAttempts) {
                reconnectAttempts++;
                const delay = 2000 * Math.pow(1.5, reconnectAttempts - 1);
                
                console.log(`Reconnecting in ${delay / 1000} seconds (attempt ${reconnectAttempts}/${maxReconnectAttempts})`);
                
                reconnectTimeout = setTimeout(() => {
                    connect();
                }, delay);
            } else {
                console.error('Max reconnect attempts reached, giving up');
            }
        }
        
        // Встановлення статусу підключення
        function setConnectionStatus(isConnected) {
            const indicator = document.getElementById('status-indicator');
            const text = document.getElementById('status-text');
            
            if (isConnected) {
                indicator.classList.remove('disconnected');
                indicator.classList.add('connected');
                text.textContent = 'Connected';
            } else {
                indicator.classList.remove('connected');
                indicator.classList.add('disconnected');
                text.textContent = 'Disconnected';
            }
        }
        
        // Обробка вхідних повідомлень
        function handleMessage(message) {
            const type = message.type;
            
            console.log('Received message type:', type);
            
            switch (type) {
                case 'initial_data':
                    console.log('Initial data received');
                    tokens = message.tokens || [];
                    exchanges = message.exchanges.map(e => e.name) || [];
                    orderbooks = message.orderbooks || {};
                    
                    // Зберігаємо дані в window.lastData
                    window.lastData = {
                        tokens,
                        exchanges,
                        orderbooks
                    };
                    
                    // Оновлення фільтра токенів
                    updateTokenFilter();
                    
                    renderTable();
                    break;
                    
                case 'orderbook_update':
                    updateOrderbook(message);
                    // Оновлюємо window.lastData
                    if (window.lastData) {
                        const { exchange, token, best_sell, best_buy } = message;
                        if (!window.lastData.orderbooks[token]) {
                            window.lastData.orderbooks[token] = {};
                        }
                        if (!window.lastData.orderbooks[token][exchange]) {
                            window.lastData.orderbooks[token][exchange] = {};
                        }
                        window.lastData.orderbooks[token][exchange] = {
                            best_sell,
                            best_buy
                        };
                    }
                    break;
                    
                case 'token_added':
                    tokens.push(message.token);
                    updateTokenFilter();
                    renderTable();
                    break;
                    
                case 'token_removed':
                    tokens = tokens.filter(t => t !== message.token);
                    updateTokenFilter();
                    renderTable();
                    break;
                    
                case 'exchange_added':
                    exchanges.push(message.exchange.name);
                    renderTable();
                    break;
                    
                case 'exchange_removed':
                    exchanges = exchanges.filter(e => e !== message.exchange);
                    renderTable();
                    break;
                    
                case 'orderbooks_cleared':
                    orderbooks = {};
                    renderTable();
                    break;
                    
                case 'full_table_update':
                    orderbooks = message.data;
                    renderTable();
                    break;
                    
                case 'error':
                    console.error('Server error:', message.message);
                    break;
                    
                default:
                    console.warn('Unknown message type:', type);
                    break;
            }
        }
        
        // Оновлення фільтра токенів
        function updateTokenFilter() {
            // Збереження поточного значення
            const currentValue = tokenFilter.value;
            
            // Очищення списку
            tokenFilter.innerHTML = '<option value="all">All Tokens</option>';
            
            // Додавання нових опцій
            tokens.forEach(token => {
                const option = document.createElement('option');
                option.value = token;
                option.textContent = token;
                tokenFilter.appendChild(option);
            });
            
            // Відновлення попереднього значення, якщо воно все ще доступне
            if (currentValue !== 'all' && tokens.includes(currentValue)) {
                tokenFilter.value = currentValue;
            }
        }
        
        // Оновлення ордербуку
        function updateOrderbook(data) {
            const { exchange, token, best_sell, best_buy } = data;
            
            console.log('Received orderbook update:', { exchange, token, best_sell, best_buy });
            
            if (!orderbooks[token]) {
                orderbooks[token] = {};
            }
            
            if (!orderbooks[token][exchange]) {
                orderbooks[token][exchange] = {};
            }
            
            orderbooks[token][exchange] = {
                best_sell,
                best_buy
            };
            
            console.log('Updated orderbooks:', orderbooks);
            
            updateTableCell(token, exchange, 'sell', best_sell);
            updateTableCell(token, exchange, 'buy', best_buy);
        }
        
        // Оновлення клітинки таблиці
        function updateTableCell(token, exchange, type, value) {
            const cell = document.getElementById(`${token}-${exchange}-${type}`);
            if (cell) {
                cell.textContent = value;
                updateCellHighlighting(cell, token, exchange, type, value);
            }
        }
        
        // Розрахунок відсотка
        function calculatePercent(value1, value2) {
            return ((value1 - value2) / value2) * 100;
        }
        
        // Розрахунок дельти
        function calculateDelta(value1, value2) {
            return value1 - value2;
        }
        
        // Оновлення підсвічування клітинки
        function updateCellHighlighting(cell, token, exchange, type, value) {
            // Видалення існуючих класів підсвічування
            cell.classList.remove('highlight-green', 'highlight-red');
            
            if (value === 'X X X' || exchanges.length < 2) return;
            
            const currentValue = parseFloat(value);
            if (isNaN(currentValue)) return;
            
            // Порівняння з іншими біржами
            for (const otherExchange of exchanges) {
                if (otherExchange === exchange) continue;
                
                if (!orderbooks[token] || !orderbooks[token][otherExchange]) continue;
                
                const otherValue = orderbooks[token][otherExchange][type === 'sell' ? 'best_sell' : 'best_buy'];
                if (otherValue === 'X X X') continue;
                
                const otherValueFloat = parseFloat(otherValue);
                if (isNaN(otherValueFloat)) continue;
                
                // Розрахунок відсотка і дельти
                const percent = calculatePercent(currentValue, otherValueFloat);
                const delta = calculateDelta(currentValue, otherValueFloat);
                
                if (type === 'sell') {
                    // Для sell ордерів підсвічуємо, якщо поточна ціна нижча
                    if ((percent <= -thresholds.percentThreshold) || (delta <= -thresholds.deltaThreshold)) {
                        cell.classList.add('highlight-green');
                        break;
                    }
                } else {
                    // Для buy ордерів підсвічуємо, якщо поточна ціна вища
                    if ((percent >= thresholds.percentThreshold) || (delta >= thresholds.deltaThreshold)) {
                        cell.classList.add('highlight-green');
                        break;
                    }
                }
            }
        }
        
        // Рендеринг таблиці
        function renderTable() {
            // Отримання фільтра токенів
            const filterValue = tokenFilter.value;
            const filteredTokens = filterValue === 'all' ? tokens : [filterValue];
            
            // Оновлення заголовків
            const exchangesHeader = document.getElementById('exchanges-header');
            exchangesHeader.parentElement.innerHTML = `
                <th>Token</th>
                <th>Type</th>
                ${exchanges.map(exchange => `<th>${exchange} <div class="exchange-status"><div class="exchange-status-indicator ${getExchangeStatus(exchange).class}"></div></div></th>`).join('')}
            `;
            
            // Оновлення тіла таблиці
            const tableBody = document.getElementById('orderbook-body');
            tableBody.innerHTML = '';
            
            filteredTokens.forEach(token => {
                // Рядок для цін Sell
                const sellRow = document.createElement('tr');
                sellRow.innerHTML = `
                    <td rowspan="2" class="token-cell">${token}</td>
                    <td class="type-cell">Sell</td>
                    ${exchanges.map(exchange => `
                        <td id="${token}-${exchange}-sell" class="sell-price ${getExchangeStatus(exchange).hasData ? '' : 'no-data'}">
                            ${orderbooks[token]?.[exchange]?.best_sell || 'X X X'}
                        </td>
                    `).join('')}
                `;
                tableBody.appendChild(sellRow);
                
                // Рядок для цін Buy
                const buyRow = document.createElement('tr');
                buyRow.innerHTML = `
                    <td class="type-cell">Buy</td>
                    ${exchanges.map(exchange => `
                        <td id="${token}-${exchange}-buy" class="buy-price ${getExchangeStatus(exchange).hasData ? '' : 'no-data'}">
                            ${orderbooks[token]?.[exchange]?.best_buy || 'X X X'}
                        </td>
                    `).join('')}
                `;
                tableBody.appendChild(buyRow);
                
                // Оновлення підсвічування
                exchanges.forEach(exchange => {
                    if (orderbooks[token]?.[exchange]) {
                        const sellCell = document.getElementById(`${token}-${exchange}-sell`);
                        const buyCell = document.getElementById(`${token}-${exchange}-buy`);
                        
                        if (sellCell) {
                            updateCellHighlighting(
                                sellCell, 
                                token, 
                                exchange, 
                                'sell', 
                                orderbooks[token][exchange].best_sell
                            );
                        }
                        
                        if (buyCell) {
                            updateCellHighlighting(
                                buyCell, 
                                token, 
                                exchange, 
                                'buy', 
                                orderbooks[token][exchange].best_buy
                            );
                        }
                    }
                });
            });
        }
        
        // Оновити всі ціни
        function refreshPrices() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    action: 'update_prices'
                }));
            }
        }
        
        // Знайти арбітражні можливості
        function findArbitrageOpportunities() {
            const opportunities = [];
            
            // Перебираємо всі токени
            tokens.forEach(token => {
                // Перебираємо всі пари бірж
                for (let i = 0; i < exchanges.length; i++) {
                    for (let j = i + 1; j < exchanges.length; j++) {
                        const exchange1 = exchanges[i];
                        const exchange2 = exchanges[j];
                        
                        if (!orderbooks[token]?.[exchange1] || !orderbooks[token]?.[exchange2]) continue;
                        
                        const book1 = orderbooks[token][exchange1];
                        const book2 = orderbooks[token][exchange2];
                        
                        if (book1.best_buy === 'X X X' || book1.best_sell === 'X X X' || 
                            book2.best_buy === 'X X X' || book2.best_sell === 'X X X') continue;
                            
                        // Арбітраж 1: Купити на біржі 1, продати на біржі 2
                        const buy1 = parseFloat(book1.best_buy);
                        const sell2 = parseFloat(book2.best_sell);
                        
                        if (!isNaN(buy1) && !isNaN(sell2) && buy1 > sell2) {
                            const profit = (buy1 - sell2) / sell2 * 100;
                            
                            if (profit >= thresholds.percentThreshold) {
                                opportunities.push({
                                    token,
                                    buyExchange: exchange2,
                                    buyPrice: sell2,
                                    sellExchange: exchange1,
                                    sellPrice: buy1,
                                    profitPercent: profit
                                });
                            }
                        }
                        
                        // Арбітраж 2: Купити на біржі 2, продати на біржі 1
                        const buy2 = parseFloat(book2.best_buy);
                        const sell1 = parseFloat(book1.best_sell);
                        
                        if (!isNaN(buy2) && !isNaN(sell1) && buy2 > sell1) {
                            const profit = (buy2 - sell1) / sell1 * 100;
                            
                            if (profit >= thresholds.percentThreshold) {
                                opportunities.push({
                                    token,
                                    buyExchange: exchange1,
                                    buyPrice: sell1,
                                    sellExchange: exchange2,
                                    sellPrice: buy2,
                                    profitPercent: profit
                                });
                            }
                        }
                    }
                }
            });
            
            // Сортування за прибутком
            opportunities.sort((a, b) => b.profitPercent - a.profitPercent);
            
            // Відображення результатів
            if (opportunities.length > 0) {
                opportunitiesSection.classList.remove('hidden');
                opportunitiesList.innerHTML = '';
                
                opportunities.forEach(opp => {
                    const item = document.createElement('div');
                    item.className = 'opportunity-item';
                    item.innerHTML = `
                        <div><strong>${opp.token}</strong>: Buy on <strong>${opp.buyExchange}</strong> at $${opp.buyPrice}, 
                        Sell on <strong>${opp.sellExchange}</strong> at $${opp.sellPrice}</div>
                        <div class="opportunity-profit">Potential profit: ${opp.profitPercent.toFixed(2)}%</div>
                    `;
                    opportunitiesList.appendChild(item);
                });
            } else {
                opportunitiesSection.classList.remove('hidden');
                opportunitiesList.innerHTML = '<p>No arbitrage opportunities found with current thresholds.</p>';
            }
        }
        
        // Запуск підключення при завантаженні сторінки
        window.addEventListener('load', () => {
            connect();
        });

        function getExchangeStatus(exchange) {
            const orderbooks = window.lastData?.orderbooks || {};
            console.log('Checking exchange status for:', exchange);
            console.log('Current orderbooks:', orderbooks);
            
            let hasData = false;
            
            // Перевіряємо наявність даних для хоча б одного токена
            for (const token of Object.keys(orderbooks)) {
                const exchangeData = orderbooks[token]?.[exchange];
                console.log(`Checking ${token} on ${exchange}:`, exchangeData);
                
                if (exchangeData && 
                    exchangeData.best_buy !== 'X X X' && 
                    exchangeData.best_buy !== '0.0' && 
                    exchangeData.best_sell !== 'X X X' && 
                    exchangeData.best_sell !== '0.0') {
                    hasData = true;
                    break;
                }
            }
            
            console.log(`Exchange ${exchange} has data:`, hasData);
            
            if (!hasData) {
                return {
                    class: 'exchange-no-data',
                    hasData: false
                };
            }
            
            return {
                class: hasData ? 'exchange-connected' : 'exchange-disconnected',
                hasData: true
            };
        }
    </script>
</body>
</html>